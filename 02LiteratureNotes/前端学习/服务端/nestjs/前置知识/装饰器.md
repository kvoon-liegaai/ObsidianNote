
```ts
const dec: ClassDecorator = () => {
  console.log('123');
};

@dec
class Test {
  name: string;
  constructor() {
    this.name = '';
  }
}

new Test();
```

## 装饰器工厂

装饰器工厂只是一个函数，它返回将在运行时被装饰器调用的表达式。


```ts
const Get = (url: string) => {
	return (target: any, key: any, descriptor: PropertyDescriptor) => {
		const fnc = descriptor.value; // 被装饰函数,可以向该函数传递一些参数数据
		axios.get(url)
			.then(res => fnc(res))
			.catch(e => fnc(e))
	}
}

class Test {
	@Get('https://api/...')
	getList(res:any){}
}
```

## 类装饰器

类装饰器声明于类声明前。类装饰器直接作用于构造函数 `constructor` ，使得类的定义得以被观察、修改、替换。

类装饰器将会被视作一个函数去调用，其唯一参数为 `constructor`

> [!attention] 注意
> 类声明不能用于声明文件 `.d.ts` 中，和其他类似环境中（例如 `declare class` 中）

```ts
function dec(constructor: Function){
	console.log(constructor);
	constructor.prototype.run = () => console.log('kwongliegaai')
}
```

### 重载构造函数

通过重载构造函数我们可以为类预设一些属性

```ts
const dec = <T extends { new (...args: any[]): object }>(constructor: T) => {
  return class extends constructor {
		age = '100'; // 预设值, 在后续类声明里的构造函数中不会受影响
  };
};

@dec
class Test {
  public name: string;
  public age: string;
  constructor(name: string, age: string) {
    this.name = name;
    this.age = age; // 无效设置
  }
}

console.log(JSON.stringify(new Test('kwongliegaai', '0')));
// {name: 'kwongliegaai', age: '100'}
```


> [!attention] 注意
> 装饰器并不会修改类的类型，例如类中没有声明 `name` 成员属性，但是装饰器为其预设了值，ts 类型系统仍然认为 `name` 并不存在在该类中。

## 方法装饰器

用于观察、修改或替换一个类方法的定义，与类装饰器一样，方法装饰器也无法在声明文件中使用。

方法装饰器在运行时当作函数被调用，传入下列==参数==：

1. `target` 对于静态成员是构造函数，对于实例成员来说是原型对象
2. `name` 成员的名称（方法名）
3.  `descriptor` 成员的属性描述符 （是否可枚举等）

如果方法装饰器返回一个值，它会被用作方法的 `descriptor`

> 注意：如果代码输出目标版本小于 es5 返回值会被忽略 

```ts
const enumerable = (value: string) => {
	return (target: any, key: stirng | symbol, descriptor: PropertyDescriptor) => {
		descriptor.enumerable = value;
	}
}
```



