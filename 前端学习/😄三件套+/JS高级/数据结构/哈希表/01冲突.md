## 冲突

解决索引冲突的两种方案

1. 链地址法
2. 开放地址法


### 链地址法(开发中用的多)

链地址法不会因为添加了某个元素后性能急速下降，开放地址法由于装填因子的影响，性能下降会越来越快，而链地址法下降比较平缓。


![[../../img/Pasted image 20220604175557.png|500]]


### 开放地址法

工作方式：**寻找空白的单元格** 来添加重复的数据

![[../../img/Pasted image 20220604180002.png]]

#### 线性探测

即线性得查找空白单元， 步长为1

- 删除：<span style="color:red">删除操作一个数据项时，不可以将这个位置下标的内容设置为 null </span>
	- 设置为 null 后会影响到后续的查询操作，通常进行特殊化处理（如果设置为 -1），==在进行线性查找的时候遇到null 会停止查找==

存在的问题——聚集

聚集：一连串填充单元都有数据，**探索多次是我们不希望看到的**

---

#### 二次探测

在线性探测的基础上对步长进行了优化

![[../../img/Pasted image 20220604182727.png|300]]

但是这样还是不够，二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。

比如讲1、11、21、31、41依次插入到哈希表中，它们映射的位置都是1，那么11需要以一为步长探测，21需要以四为步长探测，31需要为九为步长探测，41需要以十六为步长探测，只要有一项映射到1的位置，就需要更长的步长来探测，这个现象叫做二次聚集。

---

#### 再哈希法

1. 把关键字用另一个哈希函数，再做一次哈希化，用这次**哈希化的结果作为步长**。(第一次哈希话得到的是下标值)
2. 对于指定的关键字，步长在整个探测过程中是不变的，**不同的关键字使用不同的步长**


第二次哈希函数具备的特点

- 与第一个哈希函数不同（不然没有效果）
- 不能输出为0 （没有步长将会原地踏步，算法陷入死循环）

哈希函数

`step = constant - (key % constant)`

- 其中  `constant` 是质数，且小于数组的容量
- 例如：stepSize = 5 - ( key % 5 )， 满足需求，且结果不可能为 0



### 哈希化的效率

平均探测长度和平均存取时间，取决于[[00填装因子]]，随着填装因子变大，探测长度也越来越长。

