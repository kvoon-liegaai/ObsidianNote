### Composite / Aggregate Reuse Principle 组合/聚合复用原则

> 在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的。

在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。

1.  总体说来，组合/聚合复用原则告诉我们：组合或者聚合好过于继承。
2.  聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。

[参考资料（知乎）](https://zhuanlan.zhihu.com/p/158395416)

---

一、什么是组合复用原则

组合复用原则也叫合成/聚合复用原则（CARP），就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。   
**这个原则的简短表述就是：要尽量使用合成/聚合的方式，而不是使用继承。**

二、实现复用的两种方式

在面向对象的设计里，有两种基本的方法可以在不同的环境中复用已有的设计和实现，即通过组合或通过继承。

**组合**

由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：

-   新对象存取成分对象的唯一方法是通过成分对象的接口。
-   这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的。
-   这种复用支持包装。
-   这种复用所需要的依赖较少。
-   每一个新的类可以将焦点集中到一个任务上。
-   这种复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。

组合复用的缺点就是用组合复用建造的系统会有较多的对象需要管理。

**继承**   
组合几乎可以用到任何环境中去，但是继承只能用到一些环境中。

继承复用通过扩展一个已有对象的实现来得到新的功能，基类明显的捕获共同的属性和方法，而子类通过增加新的属性和方法来扩展超类的实现。

继承的优点：   
新的实现比较容易，因为基类的大部分功能都可以通过继承自动的进入子类。   
修改或扩展继承而来的实现较为容易。

继承的缺点：

-   继承复用破坏了包装，因为继承超类的的实现细节暴露给子类。由于超类的内部细节常常对子类是透明的，因此这种复用是透明的复用，又称“白箱”复用。
-   如果超类的实现发生改变，那么子类的实现也不得不发生改变。因此，当一个基类发生改变时，这种改变就会像水中投入石子引起的水波一样，将变化一圈又一圈的传导到一级又一级的子类，使设计师不得不相应地改变这些子类，以适应超类的变化。
-   从超类继承而来的实现是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。

三、使用组合还是继承

按照组合复用原则我们应该首选组合，然后才是继承，使用继承时应该严格的遵守里氏替换原则，必须满足“Is-A”的关系是才能使用继承，而组合却是一种“Has-A”的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把“Has-A”当成了“Is-A”。

下面看一个例子：

![](https://img-blog.csdn.net/20151128154626637)

人被继承到雇员，学生，经理子类。而实际上，雇员、学生和经理分别描述一种角色，而人可以同时有几种不同的角色。比如，一个人既然是经理了就一定是雇员，使用继承来实现角色，则只能使用每一个人具有一种角色，这显然是不合理的。错误的原因就是把角色的等级结构和人的等级结构混淆起来，把Has-A的关系误认为是Is-A的关系，通过下面的改正就可以正确的做到这一点。

![](https://img-blog.csdn.net/20151128154637087)

从上图可以看出，每一个人都可以有一个以上的角色，所以一个人可以同时是雇员又是经理。从这个例子可以看出，当一个类是另一个类的角色时，不应该使用继承描述这种关系。

# 设计原则核心思想  
 


1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。  
2) 针对接口编程，而不是针对实现编程。  
3) 为了交互对象之间的松耦合设计而努力